//replace this include file by your header file generated by the conversion tool

#include <WiFi.h>
#include <Time.h>

int TZ = +1; 
int Dls;                    //DayLightSaving

// Generator for 77,5 kHz (DCF-77) by Jonas woerner (c)
byte dcfBits[60] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0 };
//int Minuten = 15;
//int Stunden = 12;
const int anzahlMinutenBits = 7;
const int anzahlStundenBits = 6;
const int offsetMinutenBits = 21;
const int offsetStundenBits = 29;
byte MinutenBits[anzahlMinutenBits] = { 0 };
byte StundenBits[anzahlStundenBits] = { 0 };
int parity = 0;
// lowered signal. always on:
const byte pin1  =  11;    // = OC2A. goes to antenna
const byte pin2  =  12;    // set to LOW. goes via  22 ohms to antenna
const byte led1  =  10;
const byte led2  =   8;
const int stdled = 13;


void setup()
{
  DCF_BITS(22,22);  //set time to 15:13
  
  Serial.begin(115200);
  Serial.println("");
  Serial.println("");


}


void loop()
{
  
   
  for (int i = 0;i<58;++i)
  {
    modulate(dcfBits[i]);
    delay(995);
  }
  setLevel(1);
  //digitalWrite(LedPin,HIGH);
  delay(995);

DCF_BITS(23,22);  
  for (int i = 0;i<58;++i)
  {
    modulate(dcfBits[i]);
    delay(995);
  }
  setLevel(1);
  //digitalWrite(LedPin,HIGH);
  delay(995);

  
DCF_BITS(24,22);  
  for (int i = 0;i<58;++i)
  {
    modulate(dcfBits[i]);
    delay(995);
  }
  setLevel(1);
  //digitalWrite(LedPin,HIGH);
  delay(995);

  
DCF_BITS(25,22);  
   for (int i = 0;i<58;++i)
  {
    modulate(dcfBits[i]);
    delay(995);
  }
  setLevel(1);
  //digitalWrite(LedPin,HIGH);
  delay(995); 
}


void DCF_BITS(int Minuten, int Stunden)
{
  
  //MINUTE\\

    if (Minuten > 39)
  {
    MinutenBits[6] = 1;
    Minuten -= 40;
  }
    if (Minuten > 19)
  {
    MinutenBits[5] = 1;
    Minuten -= 20;
  }
  
    if (Minuten > 9)
  {
    MinutenBits[4] = 1;
    Minuten -= 10;
  }

  for (int i = 0; i < 4; ++i)
  {
    //MinutenBits[i] = (Minuten & (1 << i)) ? true : false;

    if ((Minuten & (1 << i)) > 0)
    {
      MinutenBits[i] = true;
    }
    else
    {
      MinutenBits[i] = false;
    }
  }
  for (int i = 0; i < anzahlMinutenBits; ++i)
      {
        dcfBits[offsetMinutenBits + i] = MinutenBits[i];
      }
  //Stunde\\

    if (Stunden > 19)
  {
    StundenBits[5] = 1;
    Stunden -= 20;
  }
     if (Stunden > 9)
  {
    StundenBits[4] = 1;
    Stunden -= 10;
  }
   

  

   for (int i = 0; i < 4; ++i)
   {
     //MinutenBits[i] = (Minuten & (1 << i)) ? true : false;

     if ((Stunden & (1 << i)) > 0)
     {
       StundenBits[i] = true;
     }
     else
     {
       StundenBits[i] = false;
     }
   }

   for (int i = 0; i < anzahlStundenBits; ++i)
   {
     dcfBits[offsetStundenBits + i] = StundenBits[i];
   }

   /*for (int n = 0; n < 6; ++n)
   {

   }*/
   ////////////////////////////
   {
     parity += dcfBits[21];
     parity += dcfBits[22];
     parity += dcfBits[23];
     parity += dcfBits[24];
     parity += dcfBits[25];
     parity += dcfBits[26];
     parity += dcfBits[27];
     if (parity % 2 == 0)
     {
       dcfBits[28] = 0;
     }
     else
     {
       dcfBits[28] = 1;
     }
     parity = 0;
   }
   ////////////////////////////
   {
     parity += dcfBits[29];
     parity += dcfBits[30];
     parity += dcfBits[31];
     parity += dcfBits[32];
     parity += dcfBits[33];
     parity += dcfBits[34];
     if (parity % 2 == 0)
     {
       dcfBits[35] = 0;
     }
     else
     {
       dcfBits[35] = 1;
     }
     parity = 0;
   }
   /////////////////////////////
   {
     parity += dcfBits[36];
     parity += dcfBits[37];
     parity += dcfBits[38];
     parity += dcfBits[39];
     parity += dcfBits[40];
     parity += dcfBits[41];
     parity += dcfBits[42];
     parity += dcfBits[43];
     parity += dcfBits[44];
     parity += dcfBits[45];
     parity += dcfBits[46];
     parity += dcfBits[47];
     parity += dcfBits[48];
     parity += dcfBits[49];
     parity += dcfBits[50];
     parity += dcfBits[51];
     parity += dcfBits[52];
     parity += dcfBits[53];
     parity += dcfBits[54];
     parity += dcfBits[55];
     parity += dcfBits[56];
     parity += dcfBits[57];
     if (parity % 2 == 0)
     {
       dcfBits[58] = 0;
     }
     else
     {
       dcfBits[58] = 1;
     }
     parity = 0;
   }
}

void setLevel(byte b) {
  switch (b) {
    case 0: break;  // open   = low sinal
    case 1: break; // closed = high signal
  }
}
void modulate(byte b)
{
  
   if (b == 0)
   {
     si5351.output_enable(SI5351_CLK0, 0); 

     delay(100);

     si5351.output_enable(SI5351_CLK0, 1); 

     delay(900);
   }
   else
   {
     si5351.output_enable(SI5351_CLK0, 0); 

     delay(200);

     si5351.output_enable(SI5351_CLK0, 1); 

     delay(800);
   }
  
}


